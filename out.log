# План по адаптации кода для работы без Gazebo

## Текущая архитектура
Сейчас код жестко завязан на Gazebo через:
1. sim::Entity, sim::EntityComponentManager - типы Gazebo
2. gz/sim и ignition/gazebo заголовки
3. Компонентная модель Gazebo для работы с сущностями

## Варианты решения

### Вариант 1: Минимальные изменения (эмуляция Gazebo)
Создать заглушки, эмулирующие интерфейсы Gazebo:

// stub_gazebo.hpp
namespace sim {
    using Entity = uint64_t;
    constexpr Entity kNullEntity = 0;
    
    class EntityComponentManager {
    public:
        template<typename T>
        bool EntityHasComponentType(Entity, uint64_t) { return false; }
        
        template<typename T>
        void CreateComponent(Entity, T) {}
        
        template<typename T>
        auto Component(Entity) { return nullptr; }
    };
    
    class Model {
    public:
        Model(Entity) {}
        bool Valid(EntityComponentManager&) { return true; }
        std::string Name(EntityComponentManager&) { return "stub_model"; }
    };
    
    namespace components {
        struct JointType { sdf::JointType Data() { return sdf::JointType::REVOLUTE; } };
        struct JointAxis { sdf::JointAxis Data() { return sdf::JointAxis(); } };
        // ... остальные компоненты
    }
}
Плюсы: Минимальные изменения в существующем коде
Минусы: Заглушки могут не полностью соответствовать поведению Gazebo

### Вариант 2: Рефакторинг с выделением абстракций (рекомендуемый)

#### Шаг 1: Создать абстрактный интерфейс для Gazebo-зависимостей

// gazebo_abstraction.hpp
namespace microros_ros2_control {

// Абстракция для Entity
class IEntity {
public:
    virtual ~IEntity() = default;
    virtual bool isValid() const = 0;
    virtual uint64_t getId() const = 0;
};

// Абстракция для EntityComponentManager
class IEntityComponentManager {
public:
    virtual ~IEntityComponentManager() = default;
    virtual bool hasComponent(uint64_t entity, const std::string& component_type) = 0;
    virtual void createComponent(uint64_t entity, const std::string& component_type) = 0;
    virtual double getJointPosition(uint64_t entity) = 0;
    virtual double getJointVelocity(uint64_t entity) = 0;
    virtual void setJointPositionCmd(uint64_t entity, double value) = 0;
    virtual void setJointVelocityCmd(uint64_t entity, double value) = 0;
    // ... другие методы
};

// Фабрика для создания правильной реализации
class GazeboAbstractionFactory {
public:
    static std::unique_ptr<IEntityComponentManager> createECM(bool use_gazebo = false);
    static std::unique_ptr<IEntity> createEntity(uint64_t id);
};

} // namespace microros_ros2_control
#### Шаг 2: Модифицировать gz_system_interface.hpp

// Вместо прямого использования sim:: типов
class GazeboSimSystemInterface : public hardware_interface::SystemInterface {
public:
    virtual bool initMicroRos(
        rclcpp::Node::SharedPtr& model_nh,
        std::map<std::string, uint64_t>& joints,  // Изменено: теперь uint64_t ID
        const hardware_interface::HardwareInfo& hardware_info,
        std::shared_ptr<IEntityComponentManager> ecm,  // Абстрактный ECM
        int& update_rate) = 0;
    
    // Добавить метод для выбора реализации
    void useGazebo(bool enable) { use_gazebo_ = enable; }
    
protected:
    bool use_gazebo_ = false;
    rclcpp::Node::SharedPtr nh_;
};
#### Шаг 3: Модифицировать gz_system.hpp и gz_system.cpp

// Вместо sim::Entity используем uint64_t
class GazeboSimSystem : public GazeboSimSystemInterface {
public:
    bool initMicroRos(
        rclcpp::Node::SharedPtr& model_nh,
        std::map<std::string, uint64_t>& joints,  // ID вместо Entity
        const hardware_interface::HardwareInfo& hardware_info,
        std::shared_ptr<IEntityComponentManager> ecm,  // Абстрактный ECM
        int& update_rate) override;
    
private:
    std::unique_ptr<GazeboSimSystemPrivate> dataPtr;
    // ... остальные методы
};
#### Шаг 4: Создать реализацию без Gazebo
// no_gazebo_ecm.hpp
class NoGazeboEntityComponentManager : public IEntityComponentManager {
public:
    NoGazeboEntityComponentManager() {
        // Внутреннее состояние для хранения данных о сущностях
        joint_positions_.clear();
        joint_velocities_.clear();
        joint_efforts_.clear();
    }
    
    bool hasComponent(uint64_t entity, const std::string& component_type) override {
        // Всегда true для базовых компонентов
        return component_type == "JointPosition" || 
               component_type == "JointVelocity" ||
               component_type == "JointTransmittedWrench";
    }
    
    void createComponent(uint64_t entity, const std::string& component_type) override {
        // Инициализация внутренних структур
        if (component_type == "JointPosition") {
            joint_positions_[entity] = 0.0;
        } else if (component_type == "JointVelocity") {
            joint_velocities_[entity] = 0.0;
        }
    }
    
    double getJointPosition(uint64_t entity) override {
        auto it = joint_positions_.find(entity);
        return it != joint_positions_.end() ? it->second : 0.0;
    }
    
    double getJointVelocity(uint64_t entity) override {
        auto it = joint_velocities_.find(entity);
        return it != joint_velocities_.end() ? it->second : 0.0;
    }
    
    void setJointPositionCmd(uint64_t entity, double value) override {
        joint_pos_cmds_[entity] = value;
    }
    
    void setJointVelocityCmd(uint64_t entity, double value) override {
        joint_vel_cmds_[entity] = value;
    }
    
private:
    std::map<uint64_t, double> joint_positions_;
    std::map<uint64_t, double> joint_velocities_;
    std::map<uint64_t, double> joint_efforts_;
    std::map<uint64_t, double> joint_pos_cmds_;
    std::map<uint64_t, double> joint_vel_cmds_;
    std::map<uint64_t, double> joint_eff_cmds_;
};
#### Шаг 5: Создать упрощенный плагин вместо gz_ros2_control_plugin

`cpp
// simple_ros2_control_node.hpp
#include "rclcpp/rclcpp.hpp"
#include "controller_manager/controller_manager.hpp"

class SimpleROS2ControlNode : public rclcpp::Node {
public:
    SimpleROS2ControlNode() : Node("simple_ros2_control") {
        // Инициализация без Gazebo
        auto ecm = std::make_shared<NoGazeboEntityComponentManager>();
        
        // Загрузка URDF
        std::string urdf_string = getURDF();
        auto hardware_info = parse_control_resources_from_urdf(urdf_string);
        
        // Создание ResourceManager
        resource_manager_ = std::make_unique<hardware_interface::ResourceManager>();
        
        // Инициализация hardware интерфейсов
        for (const auto& info : hardware_info) {
            auto system = std::make_unique<GazeboSimSystem>();
            system->useGazebo(false);  // Режим без Gazebo
            
            // Создание заглушек для joint'ов
            std::map<std::string, uint64_t> joints;
            for (size_t i = 0; i < info.joints.size(); ++i) {
                joints[info.joints[i].name] = i + 1;  // Простые ID
            }
            
            system->initMicroRos(this->shared_from_this(), joints, info, ecm, update_rate_);
            resource_manager_->import_component(std::move(system), info);
        }
        
        // Создание controller_manager
        controller_manager_ = std::make_shared<controller_manager::ControllerManager>(
            std::move(resource_manager_), executor_, "controller_manager", this->get_namespace());
        
        // Таймер для обновления
        timer_ = this->create_wall_timer(
            std::chrono::milliseconds(1000 / update_rate_),
            std::bind(&SimpleROS2ControlNode::update, this));
    }
    
private:
    void update() {
        auto now = this->now();
        auto period = now - last_update_;
        // Чтение состояний (данные от микроконтроллера придут через callback)
        controller_manager_->read(now, period);
        
        // Обновление контроллеров
        controller_manager_->update(now, period);
        
        // Запись команд (отправка на микроконтроллер)
        controller_manager_->write(now, period);
        
        last_update_ = now;
    }
    
    std::unique_ptr<hardware_interface::ResourceManager> resource_manager_;
    std::shared_ptr<controller_manager::ControllerManager> controller_manager_;
    rclcpp::TimerBase::SharedPtr timer_;
    rclcpp::Time last_update_;
    int update_rate_ = 100;  // Hz
};
`

## Краткий план действий

1. Анализ зависимостей: Выявить все места использования Gazebo API
2. Создание абстракций: IEntity, IEntityComponentManager
3. Модификация интерфейсов: Замена sim:: типов на uint64_t ID
4. Создание реализации без Gazebo: NoGazeboEntityComponentManager
5. Создание простого узла управления: Вместо плагина Gazebo
6. Адаптация логики чтения/записи: Использование callback'ов от micro-ROS
7. Тестирование: Проверка работы без Gazebo

## Основные изменения в коде

1. В `gz_system.hpp`:
   - Заменить `sim::Entity` на `uint64_t`
   - Заменить `sim::EntityComponentManager&` на `std::shared_ptr<IEntityComponentManager>`

2. В `gz_system.cpp`:
   - Убрать прямые вызовы `_ecm.Component<>()`
   - Использовать методы IEntityComponentManager

3. В `gz_ros2_control_plugin.hpp/.cpp`:
   - Либо заменить на новый узел
   - Либо модифицировать для работы с абстракциями

4. В `mini-node2test.cpp`:
   - Интегрировать с модифицированной системой
   